class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        k = len(initial)
        fa = list(range(n))
        areas = {}
        # union find and 压缩路径
        def find(x):
            if fa[x] != x:
                fa[x] = find(fa[x])
                areas[x] = areas[fa[x]]
            return fa[x]
        for node in range(n):
            areas[node] = 1
        # print("this is areas: ", areas)
        for node in range(n):
            for i in range(n):
                if node != i and graph[node][i]:
                    x = find(i)
                    y = find(node)
                    if x != y:
                        fa[x] = y
                        area = 0
                        areas[y] += areas[x]
                        areas[x] = areas[y]
        #                 print(fa)
        #                 print("add area", area, "from ", x, "to", node, "node area is ", areas[node])
        #     print()


        malware = collections.Counter(find(i) for i in initial)
        # print(malware)
        # order initial based on the areas, if the parent appeare more than once, it's 0n area
        return min(initial, key=lambda i: [(malware[find(i)] == 1) * -areas[find(i)], i])
            